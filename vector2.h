/*
 * This is a library for smart vectors which can be summed and things can be mapped on them.
 * vector2 can be used just as vector while operators are working elementwise 
 * 
 * Example of map:
 * vector2<double> a = ...
 * a.Map([](v){return v * 5});
 * 
*/

#ifndef VECTOR2
#define VECTOR2

#include <cstdio>
#include <vector>
#include <functional>
#include <iostream>
#include <type_traits>

template <class T>
class vector2 : public std::vector<T> {
 public:
  using std::vector<T>::vector;  //Inheriting constructors
  void Print() const {
    if (!this->size()) {
      std::cout << "[ ]" << std::endl;
      return;
    }
    std::cout << "[ ";
    for (int i = 0; i + 1 < this->size(); i++) {
      std::cout << (*this)[i] << ", ";
    }
    std::cout << this->back() << "]" << std::endl;
  }
  
  T Sum() const {
    T sum;
    for(int i = 0; i < this->size(); i++) {
        sum += (*this)[i];
    }
    return sum;
  }
  
  T Mean() const {
    return Sum() / this->size();
  }
  
  template <class Q>
  auto Map(Q func) -> vector2<decltype(func((*this)[0]))> const {
   vector2<decltype(func((*this)[0]))> ret;
    for(int i = 0; i < this->size(); i++) {
      ret.push_back(func((*this)[i]));
    }
    return ret;
  }

  template <class Q>
  vector2<Q> Map(std::function<Q(T)> func) const {
    vector2<Q> ret;
    for(int i = 0; i < this->size(); i++) {
      ret.push_back(func((*this)[i]));
    }
    return ret;
  }
  
  T MeanSquared() const {
    return Map([](T a) {return a * a;}).Sum();
  }
};

template<class T>
auto Sum(const T& arr) -> decltype(arr[0]) const {
  decltype(arr[0]) sum;
  for(int i = 0; i < arr.size(); i++) {
      sum += arr[i];
  }
  return sum;
}

template<class T>
auto Mean(const T& arr) -> decltype(arr[0]) const {
  return Sum / arr.size();
}

/*
template <class Q>
auto Map(Q func) -> vector2<decltype(func((*this)[0]))> const {
  vector2<decltype(func((*this)[0]))> ret;
  for(int i = 0; i < this->size(); i++) {
    ret.push_back(func((*this)[i]));
  }
  return ret;
}

template <class Q>
vector2<Q> Map(std::function<Q(T)> func) const {
  vector2<Q> ret;
  for(int i = 0; i < this->size(); i++) {
    ret.push_back(func((*this)[i]));
  }
  return ret;
}

T MeanSquared() const {
  return Map([](T a) {return a * a;}).Sum();
}

*/

template <class T>
auto Tran(const T v) -> vector2<vector2<typename std::remove_const<typename std::remove_reference<decltype(v[0][0])>::type>::type>> {
  vector2<vector2<typename std::remove_const<typename std::remove_reference<decltype(v[0][0])>::type>::type>> ret(v[0].size());
  for(int i = 0; i < ret.size(); i++)
    ret[i].resize(v.size());
  for(int i = 0; i < v.size(); i++) {
    for(int j = 0; j < v[i].size(); j++) {
      ret[j][i] = v[i][j];
    }
  }
  return ret;
}

template <class T, class Q>
bool operator< (const vector2<T>& lhs, const vector2<Q>& rhs){
  if (lhs.size() < rhs.size())
    return true;
  for(int i = 0; i < lhs.size(); i++) {
    if (lhs[i] < rhs[i]) {
      return true;
    }
    if (lhs[i] > rhs[i]) {
      return false;
    }
  }
  return false;
}

template <class T, class Q> bool operator> (const vector2<T>& lhs, const vector2<Q>& rhs){return rhs < lhs;}
template <class T, class Q> bool operator<=(const vector2<T>& lhs, const vector2<Q>& rhs){return !(lhs > rhs);}
template <class T, class Q> bool operator>=(const vector2<T>& lhs, const vector2<Q>& rhs){return !(lhs < rhs);}

template <class T>
auto operator-(vector2<T>& right) -> vector2<T> {
  vector2<T> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = -ret[i];
  }
  return ret;
}

/*
 * *************************************************************
 * Code Below this comment is generated by gen.cpp script
 * *************************************************************
*/

template <class T, class Q>
auto operator+(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] + right[0])> const {
  vector2<decltype(left[0] + right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] + right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator+(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] + right)> const {
  vector2<decltype(left[0] + right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] +  right;
  }
  return ret;
}

template <class T, class Q>
auto operator+(const T& left, const vector2<Q>& right) -> vector2<decltype(left + right[0])> const {
  vector2<decltype(left + right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left + ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator+=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] + right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] += right[i];
  }
  return left;
}

template <class T, class Q>
auto operator+=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] + right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] += right;
  }
  return left;
}

template <class T, class Q>
auto operator-(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] - right[0])> const {
  vector2<decltype(left[0] - right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] - right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator-(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] - right)> const {
  vector2<decltype(left[0] - right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] -  right;
  }
  return ret;
}

template <class T, class Q>
auto operator-(const T& left, const vector2<Q>& right) -> vector2<decltype(left - right[0])> const {
  vector2<decltype(left - right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left - ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator-=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] - right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] -= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator-=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] - right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] -= right;
  }
  return left;
}

template <class T, class Q>
auto operator*(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] * right[0])> const {
  vector2<decltype(left[0] * right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] * right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator*(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] * right)> const {
  vector2<decltype(left[0] * right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] *  right;
  }
  return ret;
}

template <class T, class Q>
auto operator*(const T& left, const vector2<Q>& right) -> vector2<decltype(left * right[0])> const {
  vector2<decltype(left * right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left * ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator*=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] * right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] *= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator*=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] * right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] *= right;
  }
  return left;
}

template <class T, class Q>
auto operator/(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] / right[0])> const {
  vector2<decltype(left[0] / right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] / right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator/(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] / right)> const {
  vector2<decltype(left[0] / right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] /  right;
  }
  return ret;
}

template <class T, class Q>
auto operator/(const T& left, const vector2<Q>& right) -> vector2<decltype(left / right[0])> const {
  vector2<decltype(left / right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left / ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator/=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] / right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] /= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator/=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] / right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] /= right;
  }
  return left;
}

template <class T, class Q>
auto operator%(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] % right[0])> const {
  vector2<decltype(left[0] % right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] % right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator%(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] % right)> const {
  vector2<decltype(left[0] % right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] %  right;
  }
  return ret;
}

template <class T, class Q>
auto operator%(const T& left, const vector2<Q>& right) -> vector2<decltype(left % right[0])> const {
  vector2<decltype(left % right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left % ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator%=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] % right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] %= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator%=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] % right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] %= right;
  }
  return left;
}

template <class T, class Q>
auto operator&(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] & right[0])> const {
  vector2<decltype(left[0] & right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] & right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator&(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] & right)> const {
  vector2<decltype(left[0] & right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] &  right;
  }
  return ret;
}

template <class T, class Q>
auto operator&(const T& left, const vector2<Q>& right) -> vector2<decltype(left & right[0])> const {
  vector2<decltype(left & right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left & ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator&=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] & right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] &= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator&=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] & right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] &= right;
  }
  return left;
}

template <class T, class Q>
auto operator|(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] | right[0])> const {
  vector2<decltype(left[0] | right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] | right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator|(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] | right)> const {
  vector2<decltype(left[0] | right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] |  right;
  }
  return ret;
}

template <class T, class Q>
auto operator|(const T& left, const vector2<Q>& right) -> vector2<decltype(left | right[0])> const {
  vector2<decltype(left | right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left | ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator|=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] | right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] |= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator|=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] | right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] |= right;
  }
  return left;
}

template <class T, class Q>
auto operator^(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] ^ right[0])> const {
  vector2<decltype(left[0] ^ right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] ^ right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator^(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] ^ right)> const {
  vector2<decltype(left[0] ^ right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] ^  right;
  }
  return ret;
}

template <class T, class Q>
auto operator^(const T& left, const vector2<Q>& right) -> vector2<decltype(left ^ right[0])> const {
  vector2<decltype(left ^ right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left ^ ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator^=(vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] ^ right[0])> {
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return left;
  }
  for(int i = 0; i < left.size(); i++) {
    left[i] ^= right[i];
  }
  return left;
}

template <class T, class Q>
auto operator^=(vector2<T>& left, const Q& right) -> vector2<decltype(left[0] ^ right[0])> {
  for(int i = 0; i < left.size(); i++) {
    left[i] ^= right;
  }
  return left;
}

template <class T, class Q>
auto operator&&(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] && right[0])> const {
  vector2<decltype(left[0] && right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] && right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator&&(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] && right)> const {
  vector2<decltype(left[0] && right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] &&  right;
  }
  return ret;
}

template <class T, class Q>
auto operator&&(const T& left, const vector2<Q>& right) -> vector2<decltype(left && right[0])> const {
  vector2<decltype(left && right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left && ret[i];
  }
  return ret;
}

template <class T, class Q>
auto operator||(const vector2<T>& left, const vector2<Q>& right) -> vector2<decltype(left[0] || right[0])> const {
  vector2<decltype(left[0] || right[0])> ret(right.size());
  if (right.size() != left.size()) {
    fprintf(stderr, "%s: %d: Error - summing arrays of different lenght!\n", __FILE__, __LINE__);
    return ret;
  }
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left[i] || right[i];
  }
  return ret;
}

template <class T, class Q>
auto operator||(const vector2<T>& left, const Q& right) -> vector2<decltype(left[0] || right)> const {
  vector2<decltype(left[0] || right)> ret(left);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = ret[i] ||  right;
  }
  return ret;
}

template <class T, class Q>
auto operator||(const T& left, const vector2<Q>& right) -> vector2<decltype(left || right[0])> const {
  vector2<decltype(left || right[0])> ret(right);
  for(int i = 0; i < ret.size(); i++) {
    ret[i] = left || ret[i];
  }
  return ret;
}

#endif  // VECTOR2
